#!/bin/bash -e

# stacker build - build docker image, also resets mtimes for package manager manifests
# stacker test - run the image in test mode (run docker-compose test stage)
# stacker run - run the image in
# stacker debug - shell into the latest image
# stacker go_pipeline_exists - check if the pipeline exists (go)
# stacker go_deploy - trigger deploy stage(s) (go)
# stacker push - push to a docker registry
# stacker purge - purge all containers

reset_colour="\033[0m\n"
bold_colour="\033[1m"
dim_colour="\033[2m"
red_colour="\033[31m"
yellow_colour="\033[33m"
blue_colour="\033[34m"
cyan_colour="\033[36m"
bin_name="$(basename $0)"
default_test_command='exit 0'
default_deploy_stage_command="echo 'sandbox'"

join() { local IFS="$1"; shift; echo "$*"; }

containsElement() {
  local e
  for e in "${@:2}"; do [[ "$e" == "$1" ]] && return 0; done
  return 1
}

echo_fail() {
  >&2 echo -e "${red_colour}[$bin_name] ERROR: $1${reset_colour}"
  [[ $2 = "true" ]] && echo -e $usage
  exit 1
}

echo_warn() {
  >&2 echo -e "${yellow_colour}[$bin_name] WARNING: $1${reset_colour}"
}

echo_info() {
  >&2 echo -e "${blue_colour}[$bin_name] INFO: $1${reset_colour}"
}

echo_debug() {
  >&2 echo -e "${cyan_colour}${dim_colour}[$bin_name] DEBUG: $1${reset_colour}"
}

ensureValidCommand() {
  local command=$2
  [[ -n "$command" ]] || echo_fail "No command specified" "true"
  containsElement "$command" "${commands[@]}" || \
    echo_fail "Invalid command: \"$command\"" "true"
}

requiredVar() {
  local required_envvar="$1"
  explanation="$2"
  [[ -n "${!required_envvar}" ]] || \
    echo_fail "Required variable $required_envvar not set. This defines the $explanation."
}

recommendedVar() {
  local recommended_envvar="$1"
  explanation="$2"
  [[ -n "${!recommended_envvar}" ]] || \
    echo_warn "Recommended variable $recommended_envvar not set. This defines the $explanation."
}

reset_mtimes() {
  local cache_files=(bower.json Gemfile Gemfile.lock package.json)
  for cache_file in "${cache_files[@]}"
  do
    [[ -f "$cache_file" ]] || continue
    echo_debug "Updating mtime for $cache_file"
    commit=$(git rev-list -n 1 HEAD "$cache_file")
    [[ -n $commit ]] || continue
    commit_time=$(git show --format=%cd --date=iso "$commit" \
      | head -n 1 \
      | sed -E s/[-+][0-9]+$// \
      | sed s/\+.*// \
      | sed -E 's/:([0-9]{2}):([0-9]{2})/\1.\2/' \
      | sed s/[\-:T\ ]//g)
    command "touch -t $commit_time \"$cache_file\""
  done
}

get_tag() {
  # The ' '  is significant - otherwise it'll treat it as an arithmetic expression
  local tag=$( ([[ -n $DOCKER_REPO ]] && echo $DOCKER_REPO) || \
    basename $(pwd))
  echo "$tag"
}

get_test_command() {
  ([[ -n $TEST_COMMAND ]] && echo $TEST_COMMAND) || \
    echo "$default_test_command"
}

get_deploy_stage_command() {
  ([[ -n $DEPLOY_STAGE_COMMAND ]] && echo $DEPLOY_STAGE_COMMAND) || \
    echo "$default_deploy_stage_command"
}

get_git_commit() {
  ([[ -n $GIT_COMMIT ]] && echo $GIT_COMMIT) || \
    git log -1 --format=%h
}

build_release() { # Build a release for compiled languages
  local build_release_tag="$(get_tag).build:$(get_git_commit)"
  local build_args=$(_whitelisted_env | sed -E "s/([^=.]+)=(.*)/--build-arg \1=\$'\2'/" | tr '\n' ' ')
  command "docker build -t $build_release_tag $build_args -f $BUILD_RELEASE_DOCKERFILE ."

  local id=`docker create $build_release_tag` # Create a container to copy out the release package.
  command "docker cp $id:/release.tar.gz ./release.tar.gz"
  command "docker rm -v $id" # Cleanup by removing the created container.
}

build() {
  reset_mtimes
  [[ -n $BUILD_RELEASE_DOCKERFILE ]] && build_release
  local build_args=$(_whitelisted_env | sed -E "s/([^=.]+)=(.*)/--build-arg \1=\$'\2'/" | tr '\n' ' ')
  command "docker build -t $(get_tag):$(get_git_commit) $build_args ."
}

command() {
  >&2 echo -e "${bold_colour}+ $1${reset_colour}"
  eval "$1" || echo_fail "Command failed: [$1] exited with code: $?"
}

debug() {
  command "docker run --rm --entrypoint=sh -it $RUN_OPTIONS $(get_tag):$(get_git_commit) -s"
}

run() {
  local run_env=$(_whitelisted_env | sed -E "s/([^=.]+)=(.*)/-e \1=\$'\2'/" | tr '\n' ' ')
  command "docker run --rm -it $RUN_OPTIONS $run_env $(get_tag):$(get_git_commit)"
}

test() {
  recommendedVar 'TEST_COMMAND' "command to run tests for the project (default: \"$default_test_command\")"
  local test_env=$(_whitelisted_env | sed -E "s/([^=.]+)=(.*)/-e \1=\$'\2'/" | tr '\n' ' ')
  command "docker run --rm --entrypoint=sh $RUN_OPTIONS $test_env $(get_tag):$(get_git_commit) -c \"$(get_test_command)\""
}

push() {
  command "docker tag $(get_tag):$(get_git_commit) $(get_tag):latest || true"
  command "docker push $(get_tag):$(get_git_commit)"
  command "docker push $(get_tag):latest"
}

purge() {
  command "docker rm \$(docker ps -a -q) && docker rmi \$(docker images -q)"
}

_env_whitelist_regex() {
  echo "${ENV_WHITELIST-=}" | xargs -n 1 | sed -E "s/(.+)/^\1=/" | tr '\n' '|' | sed -E 's/.$//'
}

_whitelisted_env() {
  env | awk "/$(_env_whitelist_regex)/"
}

go_required_vars() {
  requiredVar 'GO_HOST' "gocd host"
  requiredVar 'GO_USER' "gocd user"
  requiredVar 'GO_PASSWORD' "gocd password"
  requiredVar 'GO_PIPELINE_NAME' "gocd pipeline name"
  recommendedVar 'DEPLOY_STAGE_COMMAND' "command to run to determine the environment to deploy to (default: \"$default_deploy_stage_command\")"
  recommendedVar 'BUILD_RELEASE_DOCKERFILE' "dockerfile to build a release for compiled languages"
}

go_pipeline_exists() {
  go_required_vars

  deploy_stages=$(deploy_stage)
  [[ $? != 0 ]] && exit $?
  stages=($deploy_stages)
  for stage in "${stages[@]}"
  do
    local pipeline="$GO_PIPELINE_NAME-$stage"
    echo_debug "Checking if pipeline $pipeline exists ..."
    command "curl --fail -u '$GO_USER:$GO_PASSWORD' 'https://${GO_HOST}/go/api/pipelines/${pipeline}/status'" || \
      echo_fail "Pipeline not found: [$pipeline]"
  done
}

deploy_stage() {
  command "docker run --rm --entrypoint=sh $(get_tag):$(get_git_commit) -c \"$(get_deploy_stage_command)\"" \
    | tr ',' ' ' # Separate by spaces so we can turn it into an array
}

go_deploy() {
  go_required_vars

  deploy_stages=$(deploy_stage)
  [[ $? != 0 ]] && exit $?
  stages=($deploy_stages)
  for stage in "${stages[@]}"
  do
    local pipeline="$GO_PIPELINE_NAME-$stage"
    echo_debug "Triggering pipeline $pipeline with [IMAGE_ID=$(get_tag):$(get_git_commit)] ..."
    command "curl --fail -u '$GO_USER:$GO_PASSWORD' \
      -H 'Confirm: true' \
      --data 'variables[IMAGE_ID]=$(get_tag):$(get_git_commit)' \
      'https://${GO_HOST}/go/api/pipelines/${pipeline}/schedule'" || \
      echo_fail "Pipeline not found: [$pipeline]"
  done
}

requested_commands=($@)
commands=(build test run debug go_deploy go_pipeline_exists push purge)
usage="Usage: $bin_name {$(join '|' ${commands[@]})}"

[[ -n $requested_commands ]] || echo_fail 'No command specified' 'true'
for command in "${requested_commands[@]}"
do
  ensureValidCommand $commands $command
done
recommendedVar 'DOCKER_REPO' "docker registry location. (default: git repo name)"

for command in "${requested_commands[@]}"
do
  echo_info "Running stage: $command"
  $command
done
